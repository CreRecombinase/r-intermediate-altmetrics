---
layout: page
title: Intermediate programming with R
subtitle: Defensive programming with stopifnot
minutes: 30
---

```{r, include = FALSE}
source("tools/chunk-options.R")
```

> ## Learning Objectives {.objectives}
>
> * Check conditions with `stopifnot`
> * Send warnings with `warning`

As we saw in the debugging section, working functions can still produce unexpected errors.
And tracking down the cause of the errors can be difficult even with a debugging tool.
This is why the concept of defensive programming is important.
Defensive programming encourages us to frequently check conditions and throw an error if something is wrong.
This makes it easier to debug because we have a better idea of where the error originated.
Recall the uninformative error we received from `sum_calc_stat`: "Error in apply(df_sub, 1, mean): dim(X) must have a positive length", and the problem was actually introduced at the step before during the subsetting.
While it will invovle more work when initially writing the code, it will save time in the future when others (including your future self) use the code.

```{r echo = FALSE}
counts_raw <- read.delim("data/counts-raw.txt.gz")
```

### Checking conditions with `stopifnot`

To create an error, we can use the function `stop`.
For example, if a variable `x` needed to be a character vector, we could check for this condition with an `if` statement and throw an error if the condition was violated.

```{r}
x <- 1
if (!is.character(x)) {
  stop("x must be a character vector.")
}
```

If we had multiple conditions to check, it would take many lines of code to check all of them.
Luckily R provides the convenience function `stopifnot`.
We can list as many requirements that should evaluate to `TRUE`, and `stopifnot` throws an error if it finds one that is `FALSE`.

```{r}
stopifnot(is.character(x))
```

If `x` also had to have a length of one, we can add that condition.

```{r}
stopifnot(length(x) == 1, is.character(x))
```

Listing these conditions also serves a secondary purpose as documentation for the code.

Let's try out defensive programming by adding assertions to check the input to our function `mean_metric_per_var`.

```{r}
mean_metric_per_var <- function(metric, variable) {
  if (!is.factor(variable)) {
    variable <- as.factor(variable)
  }
  variable <- droplevels(variable)
  result <- numeric(length = length(levels(variable)))
  names(result) <- levels(variable)
  for (v in levels(variable)) {
    result[v] <- mean(metric[variable == v], na.rm = TRUE)
  }
  return(result)
}
```

We want to assert the following:

*  `metric` is a numeric vector
*  `metric` and `variable` have the same length

```{r}
mean_metric_per_var <- function(metric, variable) {
  stopifnot(is.numeric(metric),
            length(metric) == length(variable))
  if (!is.factor(variable)) {
    variable <- as.factor(variable)
  }
  variable <- droplevels(variable)
  result <- numeric(length = length(levels(variable)))
  names(result) <- levels(variable)
  for (v in levels(variable)) {
    result[v] <- mean(metric[variable == v], na.rm = TRUE)
  }
  return(result)
}
```

It still works when given proper input.

```{r}
mean_metric_per_var(counts_raw$backtweetsCount, counts_raw$year)
```

But fails instantly if given improper input.

```{r}
mean_metric_per_var(counts_raw$journal, counts_raw$year)
mean_metric_per_var(counts_raw$backtweetsCount, counts_raw$year[1:20])
```


```{r}
calc_sum_stat <- function(df, cols) {
  df_sub <- df[, cols, drop = FALSE]
  sum_stat <- apply(df_sub, 1, mean)
  return(sum_stat)
}
```


